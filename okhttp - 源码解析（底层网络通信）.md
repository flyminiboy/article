## æ‰‹æ’•Androidå¼€æºåº“-okhttpæºç è§£æï¼ˆæ‹¦æˆª,å™¨ï¼‰

ä¸€å›¾é•‡æ¥¼

![](https://mmbiz.qpic.cn/mmbiz_png/ibExRe3rl9weQJL8tibVaahtn2Pc7aiaa6D3WgmjmvJeicSia2A1ZbLfypgPIe2w6RIUKCGvryEfNpmYicVjwhNPSV7Q/0?wx_fmt=png)

åœ¨ä¸Šç¯‡æ–‡ç«  [æ‰‹æ’•Androidå¼€æºåº“-okhttpï¼ˆæ•´ä½“æµç¨‹åˆ†æï¼‰](https://mp.weixin.qq.com/s?__biz=Mzg3NzU3OTQwOA==&amp;mid=2247484012&amp;idx=1&amp;sn=56a5edd23ebcba79808a273ccc6e6f74&amp;chksm=cf219f93f85616858a2e59f0b68ef1a2b8e30b8c7e0f3100dcadcd8dec7787e1a9ecb68f6a42&token=2088204321&lang=zh_CN#rd) æˆ‘ä»¬ä»‹ç»äº†**OKhttp** äº†æ•´ä½“æµç¨‹ï¼Œå¹¶ä¸”è¯´äº†ç½‘ç»œçš„æ ¸å¿ƒæµç¨‹åœ¨ **æ‹¦æˆªå™¨** é‡Œé¢å®ç°ã€‚ä»Šå¤©æˆ‘ä»¬å°±æ¥åˆ†æè¿™éƒ¨åˆ†ä»£ç ï¼Œç”±äºå†…å®¹å¤ªå¤šï¼Œå†³å®šå°†**è·¯ç”±å’Œè¿æ¥æ± **è¿™å—å†…å®¹å•ç‹¬å†å†™ä¸€ç¯‡ğŸ˜¶ğŸ˜¶ğŸ˜¶ğŸ˜¶ğŸ˜¶ğŸ˜¶ã€‚

### æºç ç‰ˆæœ¬

* OKhttp 4.4.1

### éœ€è¦äº†è§£çš„å¿…å¤‡çŸ¥è¯†

æˆ‘ä»¬è¿™é‡Œåªæ˜¯ç®€å•çš„ä»‹ç»éœ€è¦é‚£äº›åŸºç¡€çŸ¥è¯†ï¼Œå…·ä½“çš„çŸ¥è¯†å¤§å®¶è‡ªè¡Œå­¦ä¹ å§ï¼Œä¸»è¦æ˜¯é¢å¤ªå¤§ï¼Œä¸æ˜¯ä¸€ä¿©å¥è¯å¯ä»¥è¯´æ¸…æ¥šçš„ã€‚å½“ç„¶äº†ä¸»è¦æ˜¯å°å¼Ÿå­¦è‰ºä¸ç²¾ï¼Œä¸æ•¢éšæ„é€ æ¬¡ã€‚

#### ç½‘ç»œåˆ†å±‚

|  åˆ†å±‚   | ä»£è¡¨  |
|  ----  | ----  |
| åº”ç”¨å±‚  | httpï¼Œhttpsï¼Œquicï¼Œftp |
| ä¼ è¾“å±‚  | TCPï¼ŒUDP |
| ç½‘ç»œå±‚  |  |
| æ•°æ®é“¾è·¯å±‚  |  |
| ç‰©ç†å±‚  |  |

æˆ‘ä»¬ä¸»è¦æ˜¯æ¶‰åŠä¸Šé¢ä¿©å±‚ï¼Œ**åº”ç”¨å±‚å’Œä¼ è¾“å±‚**ã€‚

#### ä»€ä¹ˆæ˜¯HTTPåè®®å’ŒHTTPSåè®®

HTTP æ˜¯åŸºäº TCP åè®®çš„ã€‚

HTTPS = HTTP + SSL/TLSï¼Œé€šè¿‡ SSLè¯ä¹¦æ¥éªŒè¯æœåŠ¡å™¨çš„èº«ä»½ï¼Œå¹¶å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´çš„é€šä¿¡è¿›è¡ŒåŠ å¯†ã€‚

è¿™é‡Œé¢è¿˜æ¶‰åŠéå¯¹ç§°åŠ å¯†ï¼Œå¯¹ç§°åŠ å¯†ï¼Œæ•°å­—è¯ä¹¦ï¼ˆåŒ…å«å…¬é’¥ï¼‰ã€‚

å…¬é’¥ç§é’¥ä¸»è¦ç”¨äºä¼ è¾“å¯¹ç§°åŠ å¯†çš„ç§˜é’¥ï¼Œè€ŒçœŸæ­£çš„åŒæ–¹å¤§æ•°æ®é‡çš„é€šä¿¡éƒ½æ˜¯é€šè¿‡å¯¹ç§°åŠ å¯†è¿›è¡Œçš„ã€‚

#### HTTPç‰ˆæœ¬

* HTTP 1.1

1. å¼•å…¥äº†æŒä¹…è¿æ¥ keep-alive
2. åŠ å…¥äº†ç®¡é“æœºåˆ¶

* HTTP 2.0

1. HTTP 2.0 ä¼šå¯¹ HTTP çš„å¤´è¿›è¡Œä¸€å®šçš„å‹ç¼©ï¼Œå°†åŸæ¥æ¯æ¬¡éƒ½è¦æºå¸¦çš„å¤§é‡ key value åœ¨ä¸¤ç«¯å»ºç«‹ä¸€ä¸ªç´¢å¼•è¡¨ï¼Œå¯¹ç›¸åŒçš„å¤´åªå‘é€ç´¢å¼•è¡¨ä¸­çš„ç´¢å¼•
2. HTTP 2.0 åè®®å°†ä¸€ä¸ª TCP çš„è¿æ¥ä¸­ï¼Œåˆ‡åˆ†æˆå¤šä¸ªæµï¼Œæ¯ä¸ªæµéƒ½æœ‰è‡ªå·±çš„ ID
3. HTTP 2.0 è¿˜å°†æ‰€æœ‰çš„ä¼ è¾“ä¿¡æ¯åˆ†å‰²ä¸ºæ›´å°çš„æ¶ˆæ¯å’Œå¸§ï¼Œå¹¶å¯¹å®ƒä»¬é‡‡ç”¨äºŒè¿›åˆ¶æ ¼å¼ç¼–ç 


#### TCPå’ŒUDP

* TCP

ä¸€ç§é¢å‘è¿æ¥çš„ã€å¯é çš„ã€åŸºäºå­—èŠ‚æµçš„ä¼ è¾“å±‚é€šä¿¡åè®®

1. TCP çš„ä¸‰æ¬¡æ¡æ‰‹
2. TCP å››æ¬¡æŒ¥æ‰‹

* UDP

æ˜¯ä¸€ç§æ— è¿æ¥çš„åè®®ã€æ— çŠ¶æ€æœåŠ¡ã€‚

#### Socket ç¼–ç¨‹

å‰é¢è¯´çš„éƒ½æ˜¯åè®®ï¼Œæ˜¯ä¸€ç§è§„èŒƒï¼Œçº¦å®šã€‚Socket å°±æ˜¯å°†è¿™ç§è§„èŒƒè¿›è¡Œäº†å®ç°ã€‚

Socket ç¼–ç¨‹è¿›è¡Œçš„æ˜¯ç«¯åˆ°ç«¯çš„é€šä¿¡ã€‚éœ€è¦å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ã€‚

ç›—å›¾ä¿©å¼ ã€‚

* TCP Socket äº¤äº’

![](https://mmbiz.qpic.cn/mmbiz_png/ibExRe3rl9weiaKzAicj3VJ8pMxRde60O0Ntxny2TlfHZfcCFnjxp55E0XmialiaeESdyyMlynjBj4WpFZLdkrnhktg/0?wx_fmt=png)

* UDP Socket äº¤äº’

![](https://mmbiz.qpic.cn/mmbiz_png/ibExRe3rl9weiaKzAicj3VJ8pMxRde60O0NdFdYWjvYdH4jEZyu9GdAhIWDabDUS687pKkTicAHYibiarI2lWbt3aycA/0?wx_fmt=png)

### æœ¬ç¯‡å…³é”®ç±»ä»‹ç»

#### RealConnection

è´Ÿè´£åº•å±‚ socket è¿æ¥ã€‚

```

  /** The low-level TCP socket. */
  // ä¸€ä¸ªä½çº§åˆ«çš„è´Ÿè´£ TCP è¿æ¥çš„ socket
  private var rawSocket: Socket? = null

  /**
   * The application layer socket. Either an [SSLSocket] layered over [rawSocket], or [rawSocket]
   * itself if this connection does not use SSL.
   */
   // åœ¨ rawSocket ä¸Šå±‚åµŒå¥— SSLSocket
  private var socket: Socket? = null
  // TLS 
  private var handshake: Handshake? = null
  // åè®®
  private var protocol: Protocol? = null
  // HTTP2 è¿æ¥å¤„ç†
  private var http2Connection: Http2Connection? = null
  // è¾“å…¥è¾“å‡ºæµ(å°±è¿™ä¹ˆç†è§£å§)
  private var source: BufferedSource? = null
  private var sink: BufferedSink? = null
```

#### Exchange

ä¼ è¾“å•ä¸ª HTTP è¯·æ±‚å’Œå“åº”å¯¹ã€‚ ç®—æ˜¯åœ¨ ExchangeCodec çš„å±‚çº§ä¸Šè¿›è¡Œäº†åŒ…è£…ï¼Œä¸»è¦æ˜¯è¿›è¡Œäº†äº‹ä»¶çš„ç›‘å¬å›è°ƒã€‚æˆ‘ä»¬åœ¨åšç½‘ç»œç›‘æ§è®¾ç½® `EventListener` ã€‚

#### ExchangeCodec

è¿™æ˜¯ä¸€ä¸ªæ¥å£ï¼Œçº¦å®šè¡Œä¸ºç¼–ç httpè¯·æ±‚ï¼Œè§£ç httpå“åº”ã€‚æœ‰ä¿©ä¸ªå®ç°ç±»ï¼Œåˆ†åˆ«å¯¹åº”**http1.1åè®®**å’Œ**http2.0åè®®**ã€‚

1. `Http1ExchangeCodec`

> ä¸€ä¸ªsocketè¿æ¥å¯ä»¥ç”¨æ¥å‘é€ HTTP/1.1 æ¶ˆæ¯
> 
> 1. å‘é€è¯·æ±‚å¤´
> 
> 2.  æ‰“å¼€ä¸€ä¸ª sink å†™è¯·æ±‚ä½“
> 
> 3. å†™å…¥å¹¶å…³é—­ sink
> 
> 4. è¯»å–å“åº”å¤´
> 
> 5. æ‰“å¼€ä¸€ä¸ª source è¯»å“åº”ä½“
> 
> 6. è¯»å–å¹¶å…³é—­ source

2. `Http2ExchangeCodec` 

> ä½¿ç”¨ HTTP/2 å¸§å¯¹è¯·æ±‚å’Œå“åº”è¿›è¡Œç¼–ç ã€‚

* Http2Connection
* Http2Stream

	* FramingSource
	* FramingSink

* Http2Writer
> å†™å…¥ HTTP/2 ä¼ è¾“å¸§ã€‚
* Http2Reader
> Reads HTTP/2 transport frames.

#### ExchangeFinder

æŸ¥æ‰¾ä¸€ä¸ªåˆé€‚çš„è¿æ¥ã€‚ä½¿ç”¨ä¸€ä¸‹ç­–ç•¥

> 1. å¦‚æœå½“å‰è°ƒç”¨å·²ç»æœ‰ä¸€ä¸ªå¯ä»¥æ»¡è¶³è¯·æ±‚çš„è¿æ¥ï¼Œåˆ™ä½¿ç”¨å®ƒã€‚
> 
> 2. å¦‚æœè¿æ¥æ± ï¼ˆRealConnectionPoolï¼‰ä¸­æœ‰å¯ä»¥æ»¡è¶³è¯·æ±‚çš„è¿æ¥ï¼Œåˆ™ä½¿ç”¨å®ƒ
> 
> 3. å¦‚æœæ²¡æœ‰ç°æœ‰è¿æ¥ï¼Œæ„å»ºè·¯ç”±ï¼ˆå¯èƒ½éœ€è¦ DNS æŸ¥æ‰¾-é˜»å¡æ“ä½œï¼‰å¹¶å†æ¬¡æ‰§è¡Œæ­¥éª¤2ï¼Œå¦‚æœè¿˜æ˜¯æ²¡æœ‰å»ºç«‹æ–°è¿æ¥

#### RealConnectionPool

è¿æ¥æ± ï¼Œåé¢ä¼šä¸“é—¨å†å†™ä¸€ç¯‡è¿›è¡Œä»‹ç»ã€‚

#### Route

è·¯ç”±ï¼Œä¸»è¦æ˜¯å°è£…äº† `Address` `Proxy` `InetSocketAddress` ï¼Œåé¢ä¼šä¸“é—¨å†å†™ä¸€ç¯‡è¿›è¡Œä»‹ç»ã€‚

#### RouteSelector

è·¯ç”±é€‰æ‹©å™¨ï¼Œåé¢ä¼šä¸“é—¨å†å†™ä¸€ç¯‡è¿›è¡Œä»‹ç»ã€‚

åœ¨ä¸Šä¸€ç¯‡çš„æµç¨‹åˆ†æï¼Œæˆ‘ä»¬è¯´åªæœ‰3.5ä¸ªæ ¸å¿ƒç±»ã€‚è¿™ç¯‡ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ã€‚

### æºç åˆ†æ

#### å°tip

* åº•å±‚I/Oæ“ä½œç”± **Okio** åº“æä¾›ã€‚æœ¬ç³»åˆ—ä¸ä¼šå¯¹ **Okio** åšä»‹ç»ï¼Œæ„Ÿå…´è¶£çš„è‡ªå·±å»äº†è§£å§ã€‚
* åº•å±‚I/Oæ“ä½œç”± **Okio** åº“æä¾›ã€‚æœ¬ç³»åˆ—ä¸ä¼šå¯¹ **Okio** åšä»‹ç»ï¼Œæ„Ÿå…´è¶£çš„è‡ªå·±å»äº†è§£å§ã€‚
* åº•å±‚I/Oæ“ä½œç”± **Okio** åº“æä¾›ã€‚æœ¬ç³»åˆ—ä¸ä¼šå¯¹ **Okio** åšä»‹ç»ï¼Œæ„Ÿå…´è¶£çš„è‡ªå·±å»äº†è§£å§ã€‚
* ç®€å•è¯´ä¸€å¥ï¼Œ**Okio** å®šä¹‰äº†è‡ªå·±çš„ä¸€å¥—ç»§æ‰¿é“¾ï¼Œ**Sourceå¯¹åº”InputStreamï¼Œ Sinkå¯¹åº”OutputStream**
* ç®€å•è¯´ä¸€å¥ï¼Œ**Okio** å®šä¹‰äº†è‡ªå·±çš„ä¸€å¥—ç»§æ‰¿é“¾ï¼Œ**Sourceå¯¹åº”InputStreamï¼Œ Sinkå¯¹åº”OutputStream**
* ç®€å•è¯´ä¸€å¥ï¼Œ**Okio** å®šä¹‰äº†è‡ªå·±çš„ä¸€å¥—ç»§æ‰¿é“¾ï¼Œ**Sourceå¯¹åº”InputStreamï¼Œ Sinkå¯¹åº”OutputStream**

#### RealCall#getResponseWithInterceptorChain

```kotlin
  @Throws(IOException::class)
  internal fun getResponseWithInterceptorChain(): Response {
    // Build a full stack of interceptors.
    // æ·»åŠ æ‹¦æˆªå™¨
    val interceptors = mutableListOf<Interceptor>()
    interceptors += client.interceptors
    interceptors += RetryAndFollowUpInterceptor(client)
    interceptors += BridgeInterceptor(client.cookieJar)
    interceptors += CacheInterceptor(client.cache)
    interceptors += ConnectInterceptor
    if (!forWebSocket) {
      interceptors += client.networkInterceptors
    }
    interceptors += CallServerInterceptor(forWebSocket)

    // æ„å»º RealInterceptorChain å¯¹è±¡
    val chain = RealInterceptorChain(
        call = this,
        interceptors = interceptors,
        index = 0,
        exchange = null,
        request = originalRequest,
        connectTimeoutMillis = client.connectTimeoutMillis,
        readTimeoutMillis = client.readTimeoutMillis,
        writeTimeoutMillis = client.writeTimeoutMillis
    )

    var calledNoMoreExchanges = false
    try {
      val response = chain.proceed(originalRequest)
      if (isCanceled()) {
        response.closeQuietly()
        throw IOException("Canceled")
      }
      return response
    } catch (e: IOException) {
      calledNoMoreExchanges = true
      throw noMoreExchanges(e) as Throwable
    } finally {
      if (!calledNoMoreExchanges) {
        noMoreExchanges(null)
      }
    }
  }
```

é»˜è®¤æ·»åŠ äº†äº”ä¸ªæ‹¦æˆªå™¨

* `RetryAndFollowUpInterceptor` å¤±è´¥é‡è¯•ï¼Œé‡å®šå‘æ‹¦æˆªå™¨
* `BridgeInterceptor` ä»åº”ç”¨ç¨‹åºåˆ°ç½‘ç»œçš„æ¡¥æ¢ã€‚æ ¹æ®ç”¨æˆ·è¯·æ±‚æ„å»ºç½‘ç»œè¯·æ±‚ï¼Œæ ¹æ®ç½‘ç»œå“åº”æ„å»ºç”¨æˆ·å“åº”ã€‚
* `CacheInterceptor` ç¼“å­˜ç›¸å…³çš„è¿‡æ»¤å™¨ï¼Œè´Ÿè´£è¯»å–ç¼“å­˜ç›´æ¥è¿”å›ã€æ›´æ–°ç¼“å­˜
* `ConnectInterceptor` æ‰“å¼€åˆ°ç›®æ ‡æœåŠ¡å™¨çš„è¿æ¥ã€‚å¼€å§‹çœŸæ­£çš„ç½‘ç»œè¯·æ±‚ã€‚
* `CallServerInterceptor` å¯¹æœåŠ¡è¿›è¡Œç½‘ç»œè°ƒç”¨ã€‚ï¼ˆå†™è¯·æ±‚ï¼Œè·å–å“åº”ï¼‰

**æ‰€æœ‰çš„ç½‘ç»œè¯·æ±‚åº•å±‚é€»è¾‘éƒ½åˆ’åˆ†åˆ°è¿™å‡ ä¸ªæ‹¦æˆªå™¨é‡Œé¢äº†ã€‚**

å’Œä¹‹å‰çš„ä¸åŒï¼Œè¿™æ¬¡æˆ‘ä»¬ä»é‡Œå‘å¤–å‘å°„çš„åˆ†æã€‚

#### CallServerInterceptor

è¿™ä¸ªæ²¡å•¥å¥½è¯´çš„ã€‚ç›´æ¥é€šè¿‡ `Exchange` è¿›è¡Œ I/O æ“ä½œã€‚å†™è¯·æ±‚ï¼Œè¯»å“åº”ã€‚

#### ConnectInterceptor

```
object ConnectInterceptor : Interceptor {
  @Throws(IOException::class)
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    // æ ¸å¿ƒä»£ç 
    val exchange = realChain.call.initExchange(chain)
    val connectedChain = realChain.copy(exchange = exchange)
    return connectedChain.proceed(realChain.request)
  }
}
```

ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ğŸ˜‚ï¼Œè¿™ä¸ªçœŸæ­£æ‰§è¡Œç½‘ç»œæ“ä½œçš„æ‹¦æˆªï¼Œåªæœ‰è¿™ä¹ˆå‡ è¡Œã€‚ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ã€‚

è°ƒç”¨é“¾æ¯”è¾ƒå¤šï¼Œä½†æ˜¯é€»è¾‘æ¯”è¾ƒç®€å•æˆ‘ä»¬ç›´æ¥è´´ä¸€ä¸ªå›¾æ¥è¯´æ˜äº†ã€‚

![](https://mmbiz.qpic.cn/mmbiz_png/ibExRe3rl9weiaKzAicj3VJ8pMxRde60O0NlUhaeKxFDzic6aLaCiaw5bqFRZoWTxVIGaGtMaxcV8rIndKiaIG6Jc86A/0?wx_fmt=png)

æ ¸å¿ƒé€»è¾‘éƒ½åœ¨ **ExchangeFinder#findConnection** é‡Œé¢ã€‚è¿™éƒ¨åˆ†ä»£ç ä¸»è¦æ˜¯åŒ…æ‹¬è·¯ç”±é€»è¾‘å’Œè¿æ¥æ± è¿æ¥å¤ç”¨é€»è¾‘ã€‚æˆ‘ä»¬åœ¨ä¸‹ä¸€ç¯‡é‡Œé¢è¯¦ç»†è¯´æ˜ã€‚

#### ExchangeFinder#findConnection

```
  private fun findConnection(
    connectTimeout: Int,
    readTimeout: Int,
    writeTimeout: Int,
    pingIntervalMillis: Int,
    connectionRetryEnabled: Boolean
  ): RealConnection {
    var foundPooledConnection = false
    var result: RealConnection? = null
    var selectedRoute: Route? = null
    var releasedConnection: RealConnection?
    val toClose: Socket?
    synchronized(connectionPool) {
      if (call.isCanceled()) throw IOException("Canceled")

	// å¾—åˆ°å½“å‰è°ƒç”¨çš„è¿æ¥
      val callConnection = call.connection // changes within this overall method
      releasedConnection = callConnection
      // åˆ¤æ–­è¿æ¥æ˜¯å¦å¯ç”¨
      toClose = if (callConnection != null && (callConnection.noNewExchanges ||
              !sameHostAndPort(callConnection.route().address.url))) {
              // ä¸å¯ç”¨è¿›è¡Œè¿æ¥é‡Šæ”¾ call.connection = null
        call.releaseConnectionNoEvents()
      } else {
        null
      }

      if (call.connection != null) {
        // 1 å½“å‰è¿æ¥å¯ç”¨
        result = call.connection
        releasedConnection = null
      }

      if (result == null) {
        // The connection hasn't had any problems for this call.
        refusedStreamCount = 0
        connectionShutdownCount = 0
        otherFailureCount = 0

        // 2 å°è¯•ä»è¿æ¥æ± é‡Œé¢è·å–å¯ç”¨è¿æ¥
        if (connectionPool.callAcquirePooledConnection(address, call, null, false)) {
          foundPooledConnection = true
          result = call.connection
        } else if (nextRouteToTry != null) {
          selectedRoute = nextRouteToTry
          nextRouteToTry = null
        }
      }
    }
    // çœç•¥ä»£ç ...
    if (result != null) {
      //å¦‚æœæˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªå·²ç»åˆ†é…æˆ–æ± åŒ–çš„è¿æ¥ï¼Œç›´æ¥è¿”å›
      return result!!
    }

    // 3.æ„å»ºæ–°çš„è·¯ç”±é€‰æ‹©å™¨
    var newRouteSelection = false
    if (selectedRoute == null && (routeSelection == null || !routeSelection!!.hasNext())) {
      var localRouteSelector = routeSelector
      if (localRouteSelector == null) {
        localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)
        this.routeSelector = localRouteSelector
      }
      newRouteSelection = true
      routeSelection = localRouteSelector.next()
    }

    var routes: List<Route>? = null
    synchronized(connectionPool) {
      if (call.isCanceled()) throw IOException("Canceled")

      if (newRouteSelection) {
        // å†æ¬¡å°è¯•ä»æ± ä¸­è·å–è¿æ¥
        routes = routeSelection!!.routes
        if (connectionPool.callAcquirePooledConnection(address, call, routes, false)) {
          foundPooledConnection = true
          result = call.connection
        }
      }

	// æ²¡æœ‰æ‰¾åˆ°å¯ç”¨è¿æ¥
      if (!foundPooledConnection) {
        if (selectedRoute == null) {
          selectedRoute = routeSelection!!.next()
        }

        // æ–°å»ºè¿æ¥
        result = RealConnection(connectionPool, selectedRoute!!)
        connectingConnection = result
      }
    }

    // å¦‚æœæˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªå·²ç»æ± åŒ–çš„è¿æ¥ï¼Œç›´æ¥è¿”å›
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
      return result!!
    }

    
    // è¿›è¡Œsocket ï¼ˆTCP+TLSï¼‰è¿æ¥
    result!!.connect(
        connectTimeout,
        readTimeout,
        writeTimeout,
        pingIntervalMillis,
        connectionRetryEnabled,
        call,
        eventListener
    )
    call.client.routeDatabase.connected(result!!.route())

    var socket: Socket? = null
    synchronized(connectionPool) {
      connectingConnection = null
      // Last attempt at connection coalescing, which only occurs if we attempted multiple
      // concurrent connections to the same host.
      if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) {
        // We lost the race! Close the connection we created and return the pooled connection.
        result!!.noNewExchanges = true
        socket = result!!.socket()
        result = call.connection

        // It's possible for us to obtain a coalesced connection that is immediately unhealthy. In
        // that case we will retry the route we just successfully connected with.
        nextRouteToTry = selectedRoute
      } else {
      	  // ç¬¦åˆæ¡ä»¶çš„è¿æ¥æ”¾åˆ°è¿æ¥æ± 
        connectionPool.put(result!!)
        call.acquireConnectionNoEvents(result!!)
      }
    }
    socket?.closeQuietly()

    eventListener.connectionAcquired(call, result!!)
    return result!!
  }
```

è¿™ä¸ªå—ä»£ç æ›´å¤šçš„åˆ†ææˆ‘ä»¬ä¼šåœ¨ä¸‹ä¸€ç¯‡è·¯ç”±å’Œè¿æ¥æ± é‡Œé¢åšåˆ†æã€‚è¿™é‡Œå¤§å®¶åªéœ€è¦çŸ¥é“é‡Œé¢çš„æµç¨‹å³å¯ã€‚

#### RealConnection#connect

```
  fun connect(
    connectTimeout: Int,
    readTimeout: Int,
    writeTimeout: Int,
    pingIntervalMillis: Int,
    connectionRetryEnabled: Boolean,
    call: Call,
    eventListener: EventListener
  ) {
    
    // çœç•¥ä»£ç ...

    while (true) {
      try {
        if (route.requiresTunnel()) {
        // éš§é“ä»£ç†
          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)
          if (rawSocket == null) {
            // We were unable to connect the tunnel but properly closed down our resources.
            break
          }
        } else {
        // è¿æ¥  socket 
        // åˆ¤æ–­æ˜¯å¦è®¾ç½®ä»£ç†
        //  ä¸è®¾ç½®    public Socket createSocket() {
        //          return new Socket();
        //      } 
        //  è®¾ç½® Socket(proxy)
        //  socket.connect(address, connectTimeout)
          connectSocket(connectTimeout, readTimeout, call, eventListener)
        }
        // å»ºç«‹åè®® ä¸»è¦æ˜¯å¹²ä¿©ä¸ªäº‹ï¼Œ
        // 1. http2
        // 1. TLS
        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)
        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
        break
      } catch (e: IOException) {
        // çœç•¥ä»£ç ...
      }
    }

	// çœç•¥ä»£ç ...
   
  }
```

æœ€åä¼šæ ¹æ®ä¸åŒçš„åè®®æ¥æ„å»ºä¸åŒçš„ `ExchangeCodec` 

```
  internal fun newCodec(client: OkHttpClient, chain: RealInterceptorChain): ExchangeCodec {
    val socket = this.socket!!
    val source = this.source!!
    val sink = this.sink!!
    val http2Connection = this.http2Connection

    return if (http2Connection != null) {
      Http2ExchangeCodec(client, this, chain, http2Connection)
    } else {
      socket.soTimeout = chain.readTimeoutMillis()
      source.timeout().timeout(chain.readTimeoutMillis.toLong(), MILLISECONDS)
      sink.timeout().timeout(chain.writeTimeoutMillis.toLong(), MILLISECONDS)
      Http1ExchangeCodec(client, this, source, sink)
    }
  }
```

ä»£ç å¾ˆç®€å•äº†å°±æ²¡æœ‰è¯´æ˜çš„å¿…è¦äº†ã€‚

#### CacheInterceptor å’Œ BridgeInterceptor

è¿™ä¿©ä¸ªä¹Ÿæ¯”è¾ƒç®€å•ï¼Œä¸å†è¯´æ˜äº†ã€‚

`BridgeInterceptor` è¿™ä¸ªç®—æ˜¯ä¸€ä¸ªç¿»è¯‘å™¨å§ï¼ŒæŠŠæˆ‘ä»¬é…ç½®çš„è¯·æ±‚ï¼Œç¿»è¯‘ä¸ºç½‘ç»œåº•å±‚ä¼ è¾“çš„æ ¼å¼ï¼›å°†ç½‘ç»œè¿”å›çš„æ•°æ®ï¼Œç¿»è¯‘æˆæˆ‘ä»¬éœ€è¦çš„å“åº”ã€‚æ‰€ä»¥èµ·åˆ°äº†ä¸€ä¸ªæ¡¥æ¥çš„ä½œç”¨å“ˆã€‚

#### RetryAndFollowUpInterceptor 

åŒæ ·æˆ‘ä»¬è´´ä¸ªå›¾çœ‹çœ‹ã€‚æ‰“å€’ä¸€åˆ‡çº¸è€è™ã€‚

![](https://mmbiz.qpic.cn/mmbiz_png/ibExRe3rl9weiaKzAicj3VJ8pMxRde60O0NSvdklbHtAyE7OqtLNNEyzJUKSJxPHAnbwibrDJh6jNF5twmBTq4ibY6w/0?wx_fmt=png)


æ‰€ä»¥å‘¢ï¼Œè¿™é‡Œé¢å°±æ˜¯ä¸€å †åˆ¤æ–­ã€‚ä½†æ˜¯æ ¸å¿ƒå°±ä¿©ä¸ª

1. å¼‚å¸¸æ˜¯å¦é‡è¯•
2. åˆ¤æ–­å“åº”ç æ˜¯å¦é‡å®šå‘

```
  override fun intercept(chain: Interceptor.Chain): Response {
    val realChain = chain as RealInterceptorChain
    var request = chain.request
    val call = realChain.call
    var followUpCount = 0
    var priorResponse: Response? = null
    var newExchangeFinder = true
    while (true) { // è¿™æ˜¯ä¸€ä¸ªæ­»å¾ªç¯
    	// æœ¬è´¨å°±ä¸€ä¸ªä½œç”¨ï¼Œæ„å»º ExchangeFinder å¤„åœ¨æ­»å¾ªç¯ä¸­ï¼Œæ‰€ä»¥åªæœ‰åœ¨ç¬¬ä¸€æ¬¡æ‰ä¼šæ„å»ºã€‚
      call.enterNetworkInterceptorExchange(request, newExchangeFinder)

      var response: Response
      var closeActiveExchange = true
      try {
        if (call.isCanceled()) {
          throw IOException("Canceled")
        }

        try {
          response = realChain.proceed(request)
          newExchangeFinder = true
        } catch (e: RouteException) {
          // å•ä¸ªè·¯ç”±è¿æ¥å‡ºé”™ï¼Œè¿›è¡Œæ¢å¤æ“ä½œ
          if (!recover(e.lastConnectException, call, request, requestSendStarted = false)) {
            throw e.firstConnectException
          }
          // è¿™ä¸ªæ˜¯æ§åˆ¶æ˜¯å¦æ„å»º ExchangeFinder çš„æ ‡è®°
          newExchangeFinder = false
          continue // ç›´æ¥å¼€å§‹ä¸‹ä¸€æ¬¡å¾ªç¯==ã€‹é‡è¯•å¼€å§‹ è¿™ä¸ªåœ°æ–¹ç†è§£å¥½
        } catch (e: IOException) {
          // ä¸æœåŠ¡é€šä¿¡å¤±è´¥ï¼Œè¿›è¡Œé‡è¯•
          if (!recover(e, call, request, requestSendStarted = e !is ConnectionShutdownException)) {
            throw e
          }
          // è¿™ä¸ªæ˜¯æ§åˆ¶æ˜¯å¦æ„å»º ExchangeFinder çš„æ ‡è®°
          newExchangeFinder = false
          continue // ç›´æ¥å¼€å§‹ä¸‹ä¸€æ¬¡å¾ªç¯==ã€‹é‡è¯•å¼€å§‹
        }

        // çœç•¥ä»£ç ...
        
        	  // è¿™ä¸ªé‡Œé¢ä¼šå¤„ç†èº«ä»½éªŒè¯ï¼Œé‡å®šå‘ï¼Œè¯·æ±‚è¶…æ—¶
	        val followUp = followUpRequest(response, exchange)
	        
      		 // çœç•¥ä»£ç ...	  
      } finally {
        call.exitNetworkInterceptorExchange(closeActiveExchange)
      }
    }
  }
```

* å¤±è´¥é‡è¯•

```
  private fun recover(
    e: IOException,
    call: RealCall,
    userRequest: Request,
    requestSendStarted: Boolean
  ): Boolean {
    // ç¦æ­¢å¤±è´¥é‡è¯•
    if (!client.retryOnConnectionFailure) return false

    // è¯·æ±‚å·²ç»å¼€å§‹å¹¶ä¸”æ˜¯åªæœŸæœ›ä¸€æ¬¡çš„è°ƒç”¨
    if (requestSendStarted && requestIsOneShot(e, userRequest)) return false

    // ä¸å¯æ¢å¤ï¼Œè‡´å‘½å¼‚å¸¸
    // åè®®é—®é¢˜ï¼Œä¸å¯æ¢å¤
    // éè¶…æ—¶ä¸­æ–­å¼‚å¸¸
    // å¦‚æœé—®é¢˜æ˜¯æ¥è‡ª X509TrustManager çš„ CertificateException 
    // è¯ä¹¦å¼‚å¸¸
    if (!isRecoverable(e, requestSendStarted)) return false

    // æ²¡æœ‰æ›´å¤šçš„è·¯ç”±è¿›è¡Œé‡è¯•å°è¯•
    if (!call.retryAfterFailure()) return false

    // å¼€å§‹æ¢å¤
    return true
  }
```


* æˆªå–éƒ¨åˆ†ä»£ç  `followUpRequest` - é‡å®šå‘

```
      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -> {
        // "If the 307 or 308 status code is received in response to a request other than GET
        // or HEAD, the user agent MUST NOT automatically redirect the request"
        if (method != "GET" && method != "HEAD") {
          return null
        }
        // æ„å»ºé‡å®šå‘è¯·æ±‚
        return buildRedirectRequest(userResponse, method)
      }
		// 300 301 302 303 
      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -> {
      	  // æ„å»ºé‡å®šå‘è¯·æ±‚
        return buildRedirectRequest(userResponse, method)
      }
```

**è¿™ä¸ªé‡Œé¢ä¸€å®šä¸è¦å¿½è§†æœ€å¤–å±‚æ˜¯ä¸€ä¸ª while(true) çš„å¾ªç¯æ¨¡å¼å•Šï¼Œæ‰€ä»¥é‡è¯•å’Œé‡å®šå‘ï¼Œä¸éœ€è¦åšå…¶ä»–çš„ï¼Œä»£ç è‡ªç„¶ä¼šæ‰§è¡Œã€‚**

### å‚è€ƒ

å›¾è§£HTTP

[https://cloud.tencent.com/developer/article/1667342](https://cloud.tencent.com/developer/article/1667342)

[https://cloud.tencent.com/developer/article/1667344](https://cloud.tencent.com/developer/article/1667344)

[https://segmentfault.com/a/1190000022145519](https://segmentfault.com/a/1190000022145519)

æå®¢æ—¶é—´-è¶£è°ˆç½‘ç»œåè®®