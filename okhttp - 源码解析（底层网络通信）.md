## æ‰‹æ’•Androidå¼€æºåº“-okhttpæºç è§£æï¼ˆæ‹¦æˆª,å™¨ï¼‰

ä¸€å›¾é•‡æ¥¼

![](https://mmbiz.qpic.cn/mmbiz_png/ibExRe3rl9weQJL8tibVaahtn2Pc7aiaa6D3WgmjmvJeicSia2A1ZbLfypgPIe2w6RIUKCGvryEfNpmYicVjwhNPSV7Q/0?wx_fmt=png)

åœ¨ä¸Šç¯‡æ–‡ç«  [æ‰‹æ’•Androidå¼€æºåº“-okhttpï¼ˆæ•´ä½“æµç¨‹åˆ†æï¼‰](https://mp.weixin.qq.com/s?__biz=Mzg3NzU3OTQwOA==&amp;mid=2247484012&amp;idx=1&amp;sn=56a5edd23ebcba79808a273ccc6e6f74&amp;chksm=cf219f93f85616858a2e59f0b68ef1a2b8e30b8c7e0f3100dcadcd8dec7787e1a9ecb68f6a42&token=2088204321&lang=zh_CN#rd) æˆ‘ä»¬ä»‹ç»äº†**OKhttp** äº†æ•´ä½“æµç¨‹ï¼Œå¹¶ä¸”è¯´äº†ç½‘ç»œçš„æ ¸å¿ƒæµç¨‹åœ¨ **æ‹¦æˆªå™¨** é‡Œé¢å®ç°ã€‚ä»Šå¤©æˆ‘ä»¬å°±æ¥åˆ†æè¿™éƒ¨åˆ†ä»£ç ï¼Œç”±äºå†…å®¹å¤ªå¤šï¼Œå†³å®šå°†**è·¯ç”±å’Œè¿æ¥æ± **è¿™å—å†…å®¹å•ç‹¬å†å†™ä¸€ç¯‡ğŸ˜¶ğŸ˜¶ğŸ˜¶ğŸ˜¶ğŸ˜¶ğŸ˜¶ã€‚

### æºç ç‰ˆæœ¬

* OKhttp 4.4.1

### èƒŒæ™¯çŸ¥è¯†

æˆ‘ä»¬å…ˆæ¥ç®€å•çš„è¡¥å……ä¸€ä¸‹ç½‘ç»œç›¸å…³çš„çŸ¥è¯†ã€‚æ–¹ä¾¿æˆ‘ä»¬ä¸‹é¢åšä»£ç åˆ†æã€‚

#### ç½‘ç»œåˆ†å±‚


åº”ç”¨å±‚ï¼ˆhttpï¼Œhttpsï¼Œquicï¼Œftpï¼‰
ä¼ è¾“å±‚ï¼ˆTCPï¼ŒUDPï¼‰
ç½‘ç»œå±‚ï¼ˆIPï¼‰
æ•°æ®é“¾è·¯å±‚
ç‰©ç†å±‚

ä»€ä¹ˆæ˜¯httpåè®®å’ŒHTTPSåè®®å‘¢

HTTP
åŸºäºTCPåè®®
è¯·æ±‚è¡Œ
è¯·æ±‚å¤´
è¯·æ±‚ä½“

http1.1

http2.0

TCPå’ŒUDP

Socket åˆæ˜¯ä»€ä¹ˆ

å®¢æˆ·ç«¯
æœåŠ¡ç«¯




### è¿æ¥

#### å°tip

* åº•å±‚I/Oæ“ä½œç”± **Okio** åº“æä¾›ã€‚æœ¬ç³»åˆ—ä¸ä¼šå¯¹ **Okio** åšä»‹ç»ï¼Œæ„Ÿå…´è¶£çš„è‡ªå·±å»äº†è§£å§ã€‚
* åº•å±‚I/Oæ“ä½œç”± **Okio** åº“æä¾›ã€‚æœ¬ç³»åˆ—ä¸ä¼šå¯¹ **Okio** åšä»‹ç»ï¼Œæ„Ÿå…´è¶£çš„è‡ªå·±å»äº†è§£å§ã€‚
* åº•å±‚I/Oæ“ä½œç”± **Okio** åº“æä¾›ã€‚æœ¬ç³»åˆ—ä¸ä¼šå¯¹ **Okio** åšä»‹ç»ï¼Œæ„Ÿå…´è¶£çš„è‡ªå·±å»äº†è§£å§ã€‚
* ç®€å•è¯´ä¸€å¥ï¼Œ**Okio** å®šä¹‰äº†è‡ªå·±çš„ä¸€å¥—ç»§æ‰¿é“¾ï¼Œ**Sourceå¯¹åº”InputStreamï¼Œ Sinkå¯¹åº”OutputStream**
* ç®€å•è¯´ä¸€å¥ï¼Œ**Okio** å®šä¹‰äº†è‡ªå·±çš„ä¸€å¥—ç»§æ‰¿é“¾ï¼Œ**Sourceå¯¹åº”InputStreamï¼Œ Sinkå¯¹åº”OutputStream**
* ç®€å•è¯´ä¸€å¥ï¼Œ**Okio** å®šä¹‰äº†è‡ªå·±çš„ä¸€å¥—ç»§æ‰¿é“¾ï¼Œ**Sourceå¯¹åº”InputStreamï¼Œ Sinkå¯¹åº”OutputStream**

#### RealConnection

è´Ÿè´£åº•å±‚ socket è¿æ¥ã€‚

```

  /** The low-level TCP socket. */
  // ä¸€ä¸ªä½çº§åˆ«çš„è´Ÿè´£ TCP è¿æ¥çš„ socket
  private var rawSocket: Socket? = null

  /**
   * The application layer socket. Either an [SSLSocket] layered over [rawSocket], or [rawSocket]
   * itself if this connection does not use SSL.
   */
   // åœ¨ rawSocket ä¸Šå±‚åµŒå¥— SSLSocket
  private var socket: Socket? = null
  // TLS 
  private var handshake: Handshake? = null
  // åè®®
  private var protocol: Protocol? = null
  // HTTP2 è¿æ¥å¤„ç†
  private var http2Connection: Http2Connection? = null
  // è¾“å…¥è¾“å‡ºæµ(å°±è¿™ä¹ˆç†è§£å§)
  private var source: BufferedSource? = null
  private var sink: BufferedSink? = null
```

#### Exchange

ä¼ è¾“å•ä¸ª HTTP è¯·æ±‚å’Œå“åº”å¯¹ã€‚ ç®—æ˜¯å¯¹ ExchangeCodec çš„å±‚çº§ä¸Šè¿›è¡Œäº†åŒ…è£…ï¼Œä¸»è¦æ˜¯è¿›è¡Œäº†äº‹ä»¶çš„ç›‘å¬å›è°ƒã€‚æˆ‘ä»¬åœ¨åšç½‘ç»œç›‘æ§è®¾ç½® `EventListener` ã€‚

#### ExchangeCodec

è¿™æ˜¯ä¸€ä¸ªæ¥å£ï¼Œçº¦å®šè¡Œä¸ºç¼–ç httpè¯·æ±‚ï¼Œè§£ç httpå“åº”ã€‚æœ‰ä¿©ä¸ªå®ç°ç±»ï¼Œåˆ†åˆ«å¯¹åº”**http1.1åè®®**å’Œ**http2.0åè®®**ã€‚

1. `Http1ExchangeCodec`

> ä¸€ä¸ªsocketè¿æ¥å¯ä»¥ç”¨æ¥å‘é€ HTTP/1.1 æ¶ˆæ¯
> 
> 1. å‘é€è¯·æ±‚å¤´
> 
> 2.  æ‰“å¼€ä¸€ä¸ª sink å†™è¯·æ±‚ä½“
> 
> 3. å†™å…¥å¹¶å…³é—­ sink
> 
> 4. è¯»å–å“åº”å¤´
> 
> 5. æ‰“å¼€ä¸€ä¸ª source è¯»å“åº”ä½“
> 
> 6. è¯»å–å¹¶å…³é—­ source

2. `Http2ExchangeCodec` 

> ä½¿ç”¨ HTTP/2 å¸§å¯¹è¯·æ±‚å’Œå“åº”è¿›è¡Œç¼–ç ã€‚

* Http2Connection
* Http2Stream

	* FramingSource
	* FramingSink

* Http2Writer
> å†™å…¥ HTTP/2 ä¼ è¾“å¸§ã€‚
* Http2Reader
> Reads HTTP/2 transport frames.

#### ExchangeFinder

#### RealConnectionPool

è¿æ¥æ± ï¼Œåé¢ä¼šä¸“é—¨å†å†™ä¸€ç¯‡è¿›è¡Œä»‹ç»ã€‚

åœ¨ä¸Šä¸€ç¯‡çš„æµç¨‹åˆ†æï¼Œæˆ‘ä»¬è¯´åªæœ‰3.5ä¸ªæ ¸å¿ƒç±»ã€‚è¿™ç¯‡ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ğŸ˜­ã€‚

### æºç åˆ†æ

#### RealCall#getResponseWithInterceptorChain

```kotlin
  @Throws(IOException::class)
  internal fun getResponseWithInterceptorChain(): Response {
    // Build a full stack of interceptors.
    // æ·»åŠ æ‹¦æˆªå™¨
    val interceptors = mutableListOf<Interceptor>()
    interceptors += client.interceptors
    interceptors += RetryAndFollowUpInterceptor(client)
    interceptors += BridgeInterceptor(client.cookieJar)
    interceptors += CacheInterceptor(client.cache)
    interceptors += ConnectInterceptor
    if (!forWebSocket) {
      interceptors += client.networkInterceptors
    }
    interceptors += CallServerInterceptor(forWebSocket)

    // æ„å»º RealInterceptorChain å¯¹è±¡
    val chain = RealInterceptorChain(
        call = this,
        interceptors = interceptors,
        index = 0,
        exchange = null,
        request = originalRequest,
        connectTimeoutMillis = client.connectTimeoutMillis,
        readTimeoutMillis = client.readTimeoutMillis,
        writeTimeoutMillis = client.writeTimeoutMillis
    )

    var calledNoMoreExchanges = false
    try {
      val response = chain.proceed(originalRequest)
      if (isCanceled()) {
        response.closeQuietly()
        throw IOException("Canceled")
      }
      return response
    } catch (e: IOException) {
      calledNoMoreExchanges = true
      throw noMoreExchanges(e) as Throwable
    } finally {
      if (!calledNoMoreExchanges) {
        noMoreExchanges(null)
      }
    }
  }
```

é»˜è®¤æ·»åŠ äº†äº”ä¸ªæ‹¦æˆªå™¨

* `RetryAndFollowUpInterceptor` å¤±è´¥é‡è¯•ï¼Œé‡å®šå‘æ‹¦æˆªå™¨
* `BridgeInterceptor` ä»åº”ç”¨ç¨‹åºåˆ°ç½‘ç»œçš„æ¡¥æ¢ã€‚æ ¹æ®ç”¨æˆ·è¯·æ±‚æ„å»ºç½‘ç»œè¯·æ±‚ï¼Œæ ¹æ®ç½‘ç»œå“åº”æ„å»ºç”¨æˆ·å“åº”ã€‚
* `CacheInterceptor` ç¼“å­˜ç›¸å…³çš„è¿‡æ»¤å™¨ï¼Œè´Ÿè´£è¯»å–ç¼“å­˜ç›´æ¥è¿”å›ã€æ›´æ–°ç¼“å­˜
* `ConnectInterceptor` æ‰“å¼€åˆ°ç›®æ ‡æœåŠ¡å™¨çš„è¿æ¥ã€‚å¼€å§‹çœŸæ­£çš„ç½‘ç»œè¯·æ±‚ã€‚
* `CallServerInterceptor` å¯¹æœåŠ¡è¿›è¡Œç½‘ç»œè°ƒç”¨ã€‚ï¼ˆå†™è¯·æ±‚ï¼Œè·å–å“åº”ï¼‰

**æ‰€æœ‰çš„ç½‘ç»œè¯·æ±‚åº•å±‚é€»è¾‘éƒ½åˆ’åˆ†åˆ°è¿™å‡ ä¸ªæ‹¦æˆªå™¨é‡Œé¢äº†ã€‚**

å’Œä¹‹å‰çš„ä¸åŒï¼Œè¿™æ¬¡æˆ‘ä»¬ä»é‡Œå‘å¤–å‘å°„çš„åˆ†æã€‚

#### RealConnection#connect

```
  fun connect(
    connectTimeout: Int,
    readTimeout: Int,
    writeTimeout: Int,
    pingIntervalMillis: Int,
    connectionRetryEnabled: Boolean,
    call: Call,
    eventListener: EventListener
  ) {
    check(protocol == null) { "already connected" }

    var routeException: RouteException? = null
    val connectionSpecs = route.address.connectionSpecs
    val connectionSpecSelector = ConnectionSpecSelector(connectionSpecs)

    if (route.address.sslSocketFactory == null) {
      if (ConnectionSpec.CLEARTEXT !in connectionSpecs) {
        throw RouteException(UnknownServiceException(
            "CLEARTEXT communication not enabled for client"))
      }
      val host = route.address.url.host
      if (!Platform.get().isCleartextTrafficPermitted(host)) {
        throw RouteException(UnknownServiceException(
            "CLEARTEXT communication to $host not permitted by network security policy"))
      }
    } else {
      if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) {
        throw RouteException(UnknownServiceException(
            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"))
      }
    }

    while (true) {
      try {
        if (route.requiresTunnel()) {
        // éš§é“ä»£ç†
          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)
          if (rawSocket == null) {
            // We were unable to connect the tunnel but properly closed down our resources.
            break
          }
        } else {
        // è¿æ¥
          connectSocket(connectTimeout, readTimeout, call, eventListener)
        }
        // æ„å»ºåè®®
        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)
        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
        break
      } catch (e: IOException) {
        socket?.closeQuietly()
        rawSocket?.closeQuietly()
        socket = null
        rawSocket = null
        source = null
        sink = null
        handshake = null
        protocol = null
        http2Connection = null
        allocationLimit = 1

        eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)

        if (routeException == null) {
          routeException = RouteException(e)
        } else {
          routeException.addConnectException(e)
        }

        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
          throw routeException
        }
      }
    }

    if (route.requiresTunnel() && rawSocket == null) {
      throw RouteException(ProtocolException(
          "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS"))
    }

    idleAtNs = System.nanoTime()
  }
```

#### CallServerInterceptor



#### RetryAndFollowUpInterceptor 

ä¸Šå›¾


#### ExchangeFinder#findConnection

```

  private fun findConnection(
    connectTimeout: Int,
    readTimeout: Int,
    writeTimeout: Int,
    pingIntervalMillis: Int,
    connectionRetryEnabled: Boolean
  ): RealConnection {
    var foundPooledConnection = false
    var result: RealConnection? = null
    var selectedRoute: Route? = null
    var releasedConnection: RealConnection?
    val toClose: Socket?
    synchronized(connectionPool) {
      if (call.isCanceled()) throw IOException("Canceled")

      val callConnection = call.connection // changes within this overall method
      releasedConnection = callConnection
      toClose = if (callConnection != null && (callConnection.noNewExchanges ||
              !sameHostAndPort(callConnection.route().address.url))) {
        call.releaseConnectionNoEvents()
      } else {
        null
      }

      if (call.connection != null) {
        // We had an already-allocated connection and it's good.
        result = call.connection
        releasedConnection = null
      }

      if (result == null) {
        // The connection hasn't had any problems for this call.
        refusedStreamCount = 0
        connectionShutdownCount = 0
        otherFailureCount = 0

        // Attempt to get a connection from the pool.
        if (connectionPool.callAcquirePooledConnection(address, call, null, false)) {
          foundPooledConnection = true
          result = call.connection
        } else if (nextRouteToTry != null) {
          selectedRoute = nextRouteToTry
          nextRouteToTry = null
        }
      }
    }
    toClose?.closeQuietly()

    if (releasedConnection != null) {
      eventListener.connectionReleased(call, releasedConnection!!)
    }
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
    }
    if (result != null) {
      // If we found an already-allocated or pooled connection, we're done.
      return result!!
    }

    // If we need a route selection, make one. This is a blocking operation.
    var newRouteSelection = false
    if (selectedRoute == null && (routeSelection == null || !routeSelection!!.hasNext())) {
      var localRouteSelector = routeSelector
      if (localRouteSelector == null) {
        localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)
        this.routeSelector = localRouteSelector
      }
      newRouteSelection = true
      routeSelection = localRouteSelector.next()
    }

    var routes: List<Route>? = null
    synchronized(connectionPool) {
      if (call.isCanceled()) throw IOException("Canceled")

      if (newRouteSelection) {
        // Now that we have a set of IP addresses, make another attempt at getting a connection from
        // the pool. This could match due to connection coalescing.
        routes = routeSelection!!.routes
        if (connectionPool.callAcquirePooledConnection(address, call, routes, false)) {
          foundPooledConnection = true
          result = call.connection
        }
      }

      if (!foundPooledConnection) {
        if (selectedRoute == null) {
          selectedRoute = routeSelection!!.next()
        }

        // Create a connection and assign it to this allocation immediately. This makes it possible
        // for an asynchronous cancel() to interrupt the handshake we're about to do.
        result = RealConnection(connectionPool, selectedRoute!!)
        connectingConnection = result
      }
    }

    // If we found a pooled connection on the 2nd time around, we're done.
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result!!)
      return result!!
    }

    // Do TCP + TLS handshakes. This is a blocking operation.
    result!!.connect(
        connectTimeout,
        readTimeout,
        writeTimeout,
        pingIntervalMillis,
        connectionRetryEnabled,
        call,
        eventListener
    )
    call.client.routeDatabase.connected(result!!.route())

    var socket: Socket? = null
    synchronized(connectionPool) {
      connectingConnection = null
      // Last attempt at connection coalescing, which only occurs if we attempted multiple
      // concurrent connections to the same host.
      if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) {
        // We lost the race! Close the connection we created and return the pooled connection.
        result!!.noNewExchanges = true
        socket = result!!.socket()
        result = call.connection

        // It's possible for us to obtain a coalesced connection that is immediately unhealthy. In
        // that case we will retry the route we just successfully connected with.
        nextRouteToTry = selectedRoute
      } else {
        connectionPool.put(result!!)
        call.acquireConnectionNoEvents(result!!)
      }
    }
    socket?.closeQuietly()

    eventListener.connectionAcquired(call, result!!)
    return result!!
  }

```



* callAcquirePooledConnection

```

```

* initExchange

```

```



### å‚è€ƒ

å›¾è§£HTTP

[https://cloud.tencent.com/developer/article/1667342](https://cloud.tencent.com/developer/article/1667342)

[https://cloud.tencent.com/developer/article/1667344](https://cloud.tencent.com/developer/article/1667344)

[https://segmentfault.com/a/1190000022145519](https://segmentfault.com/a/1190000022145519)

æå®¢æ—¶é—´-è¶£è°ˆç½‘ç»œåè®®